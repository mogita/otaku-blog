<!DOCTYPE html>
<html lang="en">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>
  理解 JavaScript Promises：上、背景和基础 · mogita
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Yun Wang">
<meta name="description" content="许诺之地 Link to heading ES2015 带来的最大变化之一就是原生的 Promise（即「许诺」，下同）特性，用来解决各种回调问题，让开发者写出同步风格的异步代码。 讲">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="理解 JavaScript Promises：上、背景和基础"/>
<meta name="twitter:description" content="许诺之地 Link to heading ES2015 带来的最大变化之一就是原生的 Promise（即「许诺」，下同）特性，用来解决各种回调问题，让开发者写出同步风格的异步代码。 讲"/>

<meta property="og:title" content="理解 JavaScript Promises：上、背景和基础" />
<meta property="og:description" content="许诺之地 Link to heading ES2015 带来的最大变化之一就是原生的 Promise（即「许诺」，下同）特性，用来解决各种回调问题，让开发者写出同步风格的异步代码。 讲" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/understanding-javascript-promise-part-1.html" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-18T15:34:24+00:00" />
<meta property="article:modified_time" content="2022-08-28T11:08:04+08:00" />





<link rel="canonical" href="http://localhost:1313/posts/understanding-javascript-promise-part-1.html">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 




<link rel="icon" type="image/png" href="/img/favicons/favicon32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicons/favicon16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/img/favicons/favicon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/img/favicons/favicon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.101.0" />





  </head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      mogita
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/index.xml">RSS</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags.html">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about.html">About</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/understanding-javascript-promise-part-1.html">
              理解 JavaScript Promises：上、背景和基础
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2016-07-18T15:34:24Z">
                July 18, 2016
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              10-minute read
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/%E8%AF%91%E6%96%87/">译文</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h2 id="许诺之地">
  许诺之地
  <a class="heading-link" href="#%e8%ae%b8%e8%af%ba%e4%b9%8b%e5%9c%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>ES2015 带来的最大变化之一就是<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">原生的 Promise</a>（即「许诺」，下同）特性，用来解决各种回调问题，让开发者写出同步风格的异步代码。</p>
<p>讲道理来说，Promise 和 Generator 代表着异步的新标准。无论你是否使用它们，都应该了解一下。</p>
<p>Promise 特性由很简单的 API 构成，但学习曲线稍显陡峭。初学者或许会感到它的概念十分艰涩，需要一个了解的过程和充分的示例。</p>
<p>读完本文后，你将能做到：</p>
<ul>
<li>明白为什么会有 Promise，以及它们能解决什么问题；</li>
<li>解释什么是 Promise，包括它们的实现以及应用；</li>
<li>将常见的回调设计用 Promise 进行重写</li>
</ul>
<p>注意，文中示例均以 Node 环境为前提，你可以手动拷贝代码，也可以 <a href="https://github.com/Peleke/promises/">clone 我的代码</a>。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>git clone https://github.com/Peleke/promises/
</span></span><span style="display:flex;"><span>git checkout Part_1-Basics
</span></span></code></pre></div><p>下面是本文的整体框架：</p>
<ul>
<li>回调的问题</li>
<li>Promise：定义以及 A+ 规范</li>
<li>Promise 和反控制反转</li>
<li>用 Promise 控制流程</li>
<li>理解 <code>then</code>、<code>reject</code> 和 <code>resolve</code></li>
</ul>
<h2 id="异步式">
  异步式
  <a class="heading-link" href="#%e5%bc%82%e6%ad%a5%e5%bc%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>任何写过一些 JavaScript 代码的开发者都知道，它是「非阻塞」或「异步执行」的。这究竟是什么意思？</p>
<h4 id="同步和异步">
  同步和异步
  <a class="heading-link" href="#%e5%90%8c%e6%ad%a5%e5%92%8c%e5%bc%82%e6%ad%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p><strong>同步代码</strong>会逐行运行，前行执行完了才执行后行。同步代码的近义词是阻塞执行，因为一行代码的执行会阻塞下面代码的执行，直到这行代码执行完毕。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// readfile_sync.js
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This example uses Node, and so won&#39;t run in the browser. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> filename <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;text.txt&#39;</span><span style="color:#eceff4">,</span> 
</span></span><span style="display:flex;"><span>            fs <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Reading file . . . &#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// readFileSync BLOCKS execution until it returns. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">//   The program will wait to execute anything else until this operation finishes. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> file <span style="color:#81a1c1">=</span> fs<span style="color:#eceff4">.</span>readFileSync<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This will ALWAYS print after readFileSync returns. . . 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Done reading file.&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// . . . And this will ALWAYS print the contents of &#39;file&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">`Contents: </span><span style="color:#a3be8c">${</span>file<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">()</span><span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span> 
</span></span></code></pre></div><p><img src="/img/1.png" alt="1"></p>
<p><strong>异步代码</strong>正好相反：当前正在执行的这行代码不会阻止接下来的代码，就算它正在执行需要较长时间的操作，例如 I/O 或网络请求。这就是「非阻塞代码」。下面是用异步方式模拟上面的代码段：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// readfile_async.js
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This example uses Node, so it won&#39;t run in the browser.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> filename      <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;text.txt&#39;</span><span style="color:#eceff4">,</span> 
</span></span><span style="display:flex;"><span>            fs      <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">),</span>
</span></span><span style="display:flex;"><span>        getContents <span style="color:#81a1c1">=</span> <span style="color:#81a1c1;font-weight:bold">function</span> printContent <span style="color:#eceff4">(</span>file<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#81a1c1;font-weight:bold">try</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#81a1c1;font-weight:bold">return</span> file<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#eceff4">}</span> <span style="color:#81a1c1;font-weight:bold">catch</span> <span style="color:#eceff4">(</span>TypeError<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#81a1c1;font-weight:bold">return</span> file<span style="color:#eceff4">;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#eceff4">}</span> 
</span></span><span style="display:flex;"><span>      <span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Reading file . . . &#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#34;=&#34;</span><span style="color:#eceff4">.</span>repeat<span style="color:#eceff4">(</span><span style="color:#b48ead">76</span><span style="color:#eceff4">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// readFile executes ASYNCHRONOUSLY. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">//   The program will continue to execute past LINE A while 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">//   readFile does its business. We&#39;ll talk about callbacks in detail
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">//   soon -- for now, just pay mind to the the order of the log
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">//   statements.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">let</span> file<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> contents<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  file <span style="color:#81a1c1">=</span> contents<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`Uh, actually, now I&#39;m done. Contents are: </span><span style="color:#a3be8c">${</span> getContents<span style="color:#eceff4">(</span>file<span style="color:#eceff4">)</span> <span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">});</span> <span style="color:#616e87;font-style:italic">// LINE A
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// These will ALWAYS print BEFORE the file read is complete.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// Well, that&#39;s both misleading and useless.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">`Done reading file. Contents are: </span><span style="color:#a3be8c">${</span>getContents<span style="color:#eceff4">(</span>file<span style="color:#eceff4">)</span><span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span> 
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#34;=&#34;</span><span style="color:#eceff4">.</span>repeat<span style="color:#eceff4">(</span><span style="color:#b48ead">76</span><span style="color:#eceff4">));</span>
</span></span></code></pre></div><p><img src="/img/2.png" alt="2"></p>
<p>同步代码最大的好处在于可读，便于理解。同步代码自上而下顺序执行，与我们读书的方式相同。第 n 行的代码一定比第 n+1 行代码先执行完。</p>
<p>但同步代码的坏处在于执行慢。比如，用户点击按钮后，浏览器要在完成一个 2 秒的网络请求之后，再继续响应用户操作，这种体验是无法接受的。</p>
<p>这个例子也正好说明为什么 JavaScript 是非阻塞型的。</p>
<h4 id="异步式带来的挑战">
  异步式带来的挑战
  <a class="heading-link" href="#%e5%bc%82%e6%ad%a5%e5%bc%8f%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%8c%91%e6%88%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>异步代码带来了速度上的提升，但不再具有线性特征。即使上例中琐碎的代码段也是如此。请注意：</p>
<ul>
<li>无法知道 <code>file</code> 什么时候可用，除非将控制权交给 <code>readFile</code> 并让它在准备好的时刻通知我们</li>
<li>我们的代码不再按照它的书写顺序来执行，理解起来会不那么直观</li>
</ul>
<p>这几点问题将成为本文接下来讨论的中心。</p>
<h2 id="回调和回退">
  回调和回退
  <a class="heading-link" href="#%e5%9b%9e%e8%b0%83%e5%92%8c%e5%9b%9e%e9%80%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>我们来精简一下异步 <code>readFile</code> 代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> filename <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;throwaway.txt&#39;</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>      fs       <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">let</span> file<span style="color:#eceff4">,</span> useless<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>useless <span style="color:#81a1c1">=</span> fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> callback <span style="color:#eceff4">(</span>error<span style="color:#eceff4">,</span> contents<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  file <span style="color:#81a1c1">=</span> contents<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`Got it. Contents are: </span><span style="color:#a3be8c">${</span>contents<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`. . . But useless is still </span><span style="color:#a3be8c">${</span>useless<span style="color:#a3be8c">}</span><span style="color:#a3be8c">.`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// Thanks to Rava for catching an error in this line.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">`File is </span><span style="color:#a3be8c">${</span>useless<span style="color:#a3be8c">}</span><span style="color:#a3be8c">, but that&#39;ll change soon.`</span><span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>由于 <code>readFile</code> 是非阻塞的，它不得不立即返回，以便代码继续往下执行。而「立即返回」也就意味着它没有足够的时间来完成 I/O 操作，它除了返回 <code>undefined</code> 之外也别无他法。但我们需要的是在 <code>readFile</code> 方法真正地读完文件。</p>
<p>问题来了，我们怎么知道读取已经完成？</p>
<p>答案也很简单：无法预知。但是，<code>readFile</code> 方法可以。上面的代码段中，我们向<code>readFile</code> 方法传递了两个参数：文件名，以及一个函数，这个函数就叫<strong>回调函数</strong>。在文件读取完成的时刻，它就会被执行。</p>
<p>把这段代码换成白话就是：「<code>readFile</code>，请查看一下 <code>${__dirname}/${filename}</code>这个路径里面有什么内容，这个过程需要一点时间。你查看完之后，请调用 <code>callback</code> 方法，传入 <code>contents</code>，如果有错误请让我知道 <code>error</code> 是什么。」</p>
<p>其要点就是我们无法获知读取文件的完成时间，只有 readFile 方法自己知道。这就是为什么我们要给它传递一个回调函数，并且信任 <code>readFile</code> 会对这个函数做正确的事情。</p>
<p>这便是以往人们使用异步方法的基本方式：用参数调用它，并传递一个回调函数来处理结果。</p>
<p>回调是一种异步解决方案，但它们并不完美。两个比较大的问题在于：</p>
<ol>
<li>控制反转</li>
<li>复杂的错误处理方式</li>
</ol>
<h4 id="控制反转">
  控制反转
  <a class="heading-link" href="#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>首先是关于信任的问题。</p>
<p>当我们向 <code>readFile</code> 传递回调函数时，我们<strong>相信</strong>它会执行这个回调。然而，事实上它却从没保证过它会执行这个回调。就算它确实会被调用，也没人保证传递给这个回调函数的参数将一定正确，或者顺序一定正确，又或者执行的次数也一定正确。</p>
<p>现实当中，这倒不是什么致命的问题：我们已经写了 20 多年回调，从未让网络崩坏。在此基础之上，我们觉得，把控制权直接交给 Node 核心代码应该也是安全的。</p>
<p>但是，把一个应用中最关键的部分交给第三方去管理，总感觉有点冒险，过去已经造成了无数个难以捕捉的 <a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a>。</p>
<h4 id="显式错误处理">
  显式错误处理
  <a class="heading-link" href="#%e6%98%be%e5%bc%8f%e9%94%99%e8%af%af%e5%a4%84%e7%90%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>在同步式编程中，我们可以用 <code>try</code>/<code>catch</code>/<code>finally</code> 来把握错误处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This example uses Node, and so won&#39;t run in the browser. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> filename <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;text.txt&#39;</span><span style="color:#eceff4">,</span> 
</span></span><span style="display:flex;"><span>       fs        <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Reading file . . . &#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">let</span> file<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">try</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#616e87;font-style:italic">// Wrong filename. D&#39;oh!
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  file <span style="color:#81a1c1">=</span> fs<span style="color:#eceff4">.</span>readFileSync<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename <span style="color:#81a1c1">+</span> <span style="color:#a3be8c">&#39;a&#39;</span><span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">);</span> 
</span></span><span style="display:flex;"><span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`Got it. Contents are: &#39;</span><span style="color:#a3be8c">${</span>file<span style="color:#a3be8c">}</span><span style="color:#a3be8c">&#39;`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span> <span style="color:#81a1c1;font-weight:bold">catch</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`There was a/n </span><span style="color:#a3be8c">${</span>err<span style="color:#a3be8c">}</span><span style="color:#a3be8c">: file is </span><span style="color:#a3be8c">${</span>file<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">&#39;Catching errors, like a bo$$.&#39;</span> <span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>而在异步式编程中，还想这么写的话，就走远了：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This example uses Node, and so won&#39;t run in the browser. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> filename <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;throwaway.txt&#39;</span><span style="color:#eceff4">,</span> 
</span></span><span style="display:flex;"><span>        fs       <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Reading file . . . &#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">let</span> file<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">try</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#616e87;font-style:italic">// Wrong filename. D&#39;oh!
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename <span style="color:#81a1c1">+</span> <span style="color:#a3be8c">&#39;a&#39;</span><span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> contents<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>    file <span style="color:#81a1c1">=</span> contents<span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#616e87;font-style:italic">// This shouldn&#39;t run if file is undefined
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`Got it. Contents are: &#39;</span><span style="color:#a3be8c">${</span>file<span style="color:#a3be8c">}</span><span style="color:#a3be8c">&#39;`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span> <span style="color:#81a1c1;font-weight:bold">catch</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#616e87;font-style:italic">// In this case, catch should run, but it never will.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  <span style="color:#616e87;font-style:italic">//   This is because readFile passes errors to the callback -- it does /not/
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  <span style="color:#616e87;font-style:italic">//   throw them.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`There was a/n </span><span style="color:#a3be8c">${</span>err<span style="color:#a3be8c">}</span><span style="color:#a3be8c">: file is </span><span style="color:#a3be8c">${</span>file<span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">}</span>
</span></span></code></pre></div><p>这段代码根本不会以设想的方式执行。因为 <code>try</code> 语句块包含 <code>readFile</code> 方法，后者永远会成功地返回一个 <code>undefined</code> 值。也就是说，<code>try</code> 永远会成功完成，而不会发生任何意外。</p>
<p>要捕获 <code>readFile</code> 产生的错误的方式只有一种，就是给它传递一个回调函数，并在这个回调中获得错误信息，然后再来处理错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a3be8c">&#34;use strict&#34;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// This example uses Node, and so won&#39;t run in the browser. 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span><span style="color:#81a1c1;font-weight:bold">const</span> filename <span style="color:#81a1c1">=</span> <span style="color:#a3be8c">&#39;throwaway.txt&#39;</span><span style="color:#eceff4">,</span>
</span></span><span style="display:flex;"><span>        fs       <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;Reading file . . . &#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">`</span><span style="color:#a3be8c">${</span>__dirname<span style="color:#a3be8c">}</span><span style="color:#a3be8c">/</span><span style="color:#a3be8c">${</span>filename <span style="color:#81a1c1">+</span> <span style="color:#a3be8c">&#39;a&#39;</span><span style="color:#a3be8c">}</span><span style="color:#a3be8c">`</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> contents<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">if</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span> <span style="color:#616e87;font-style:italic">// catch
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>    console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`There was a/n </span><span style="color:#a3be8c">${</span>err<span style="color:#a3be8c">}</span><span style="color:#a3be8c">.`</span> <span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">}</span> <span style="color:#81a1c1;font-weight:bold">else</span>   <span style="color:#eceff4">{</span> <span style="color:#616e87;font-style:italic">// try
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>    console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">(</span> <span style="color:#a3be8c">`Got it. File contents are: &#39;</span><span style="color:#a3be8c">${</span>file<span style="color:#a3be8c">}</span><span style="color:#a3be8c">&#39;`</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">}</span>
</span></span><span style="display:flex;"><span><span style="color:#eceff4">});</span>
</span></span></code></pre></div><p>这个例子的代码还不算太糟糕，但是工程量足够大时，这些问题会后患无穷。</p>
<p>Promise 则一下解决了这两个问题等一系列不足之处，通过「反控制反转」，和「同步化」异步代码，来实现我们更熟悉的错误处理。</p>
<h2 id="promise-机制">
  Promise 机制
  <a class="heading-link" href="#promise-%e6%9c%ba%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>假设你从 O’Reilly 订购了全套「<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/README.md#you-dont-know-js-book-series">You Don’t Know JS</a>」丛书。你把辛苦搬砖挣来的钞票给了他们，他们发给你一张收据，声明你将在下周一收到一套崭新的图书。在那之前，你都并未拥有这套图书。但你可以相信，一定会收到，因为他们保证过（promised）一定会寄送。</p>
<p>基于这种 Promise，在图书送达之前，你就可以计划好每天要阅读多少本，计划借给朋友哪几本，甚至给老板请好一周的休假来奋力读书。在制定这些计划的时候，你其实都处于并未拥有这套图书的状态，你仅仅是知道你会拥有。</p>
<p>当然，O’Reilly 可能过几天之后告诉你，由于七七八八的原因，订单无法完成了。到那时，你可以取消每日阅读计划，告诉你朋友他们不用等了（因为你自己都拿不到书），然后告诉老板，下周你会照常上班。</p>
<p><strong>Promise</strong>，就像这张收据一样，是替一个还未就绪的值占位的对象，但稍后一定会就绪。换句话说，一个未来的值。你可以把 Promise 当成一个你正在等待的值，并在假设你已获得它的前提下编写代码。</p>
<p>如果在事件过程中出现岔子，Promise 会在自身内部流程去处理中断的地方，并且让你用一个特殊的 <code>catch</code> 关键词来处理错误。这和同步式的代码有点不一样，但至少比异步处理一堆错误要舒服。</p>
<p>并且，由于 Promise 会在一个值准备就绪时将其传递给你，你就可以决定要如何使用这个值。这就解决了控制反转的问题：你自己来直接掌握应用的逻辑，无需把控制权转交给第三方。</p>
<h4 id="promise-的生命周期状态states简介">
  Promise 的生命周期：状态（States）简介
  <a class="heading-link" href="#promise-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%8a%b6%e6%80%81states%e7%ae%80%e4%bb%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>假设你用 Promise 进行了一次 API 调用。</p>
<p>由于服务器不可能立即发回响应，Promise 是不可能立即获得最终值的，也不可能立即报告错误。这个状态下的 Promise 被称为 <strong>Pending</strong>（等候中），好比你在等待订购的那套新书。</p>
<p>一旦服务器发回了响应，就会产生两种可能：</p>
<ol>
<li>Promise 得到了它期待的值，这个状态被称为 <strong>Fulfilled</strong>（已满足）。好比你收到了那套书。</li>
<li>请求事件中出现了错误，这时 Promise 的状态被称为 <strong>Rejected</strong>（被拒绝）。这就好比你收到通知，购书订单无法完成了。</li>
</ol>
<p>这三个状态就是 Promise 的所有可能状态。一旦 Promise 变成了 Fulfilled 或 Rejected，则无法再转化为任何其他状态了。</p>
<p>关于概念的阐释就说这么远，下面我们来看看究竟怎样应用这些东西。</p>
<h2 id="promise-的基础方法">
  Promise 的基础方法
  <a class="heading-link" href="#promise-%e7%9a%84%e5%9f%ba%e7%a1%80%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>引用 <a href="https://promisesaplus.com/">Promises/A+ 标准</a>的一段话：</p>
<blockquote>
<p>Promise 代表一个异步操作的最终结果。与 Promise 进行交互的主要方式，是使用它的 <code>then</code> 方法。该方法会注册回调函数，接收 Promise 的最终值，或 Promise 无法被满足的原因。</p>
</blockquote>
<p>接下来的部分，我们将对 Promise 的基本用法进行详细介绍：</p>
<ol>
<li>用构造器创建 Promise</li>
<li>用 <code>resolve</code> 处理成功事件</li>
<li>用 <code>rejected</code> 处理错误事件</li>
<li>用 <code>then</code> 和 <code>catch</code> 来建立控制流程</li>
</ol>
<p>在这个例子中，我们将使用 Promise 来搞定上边 <code>fs.readFile</code> 的遗留代码。</p>
<h2 id="创建-promise">
  创建 Promise
  <a class="heading-link" href="#%e5%88%9b%e5%bb%ba-promise">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>最基本的 Promise 创建方法就是通过构造器直接创建。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a3be8c">&#39;use strict&#39;</span><span style="color:#eceff4">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> fs <span style="color:#81a1c1">=</span> require<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;fs&#39;</span><span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> text <span style="color:#81a1c1">=</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">new</span> <span style="color:#81a1c1">Promise</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#616e87;font-style:italic">// Does nothing
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>  <span style="color:#eceff4">})</span>
</span></span></code></pre></div><p>注意，我们向 Promise 构造器传递了一个函数作为参数。在这里我们将告诉 Promise 怎样执行异步操作、得到期待值后需要做什么，以及出错了怎么办。细说起来就是：</p>
<ol>
<li><code>Resolve</code> 参数也是一个函数，里面包含当获得<strong>期待值</strong>的时候我们想要做的事。当我们得到了期待值 <code>val</code> 的时候，我们这样调用：<code>resolve(val)</code>。</li>
<li><code>Reject</code>参数也是一个函数，代表得到<strong>错误</strong>的时候我们要怎么做。如果有错误<code>err</code>，则要这样调用：<code>reject(err)</code>。</li>
<li>最后，我们传递给 Promise 构造器的函数将处理异步代码本身。如果它按期待返回了，我们就调用 <code>resolve</code> 并传入获得的返回值。如果抛出错误，我们就调用<code>reject</code> 并传入错误。</li>
</ol>
<p>我们的示例需要把 <code>fs.readFile</code> 封装成一个 Promise。那么，应该怎样写 <code>resolve</code> 和<code>reject</code> 呢？</p>
<ol>
<li>在成功的事件中，我们用 <code>console.log</code> 打印文件内容</li>
<li>在错误的事件中，我们做一样的事：用 <code>console.log</code> 打印错误信息</li>
</ol>
<p>也就是这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// constructor.js
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> resolve <span style="color:#81a1c1">=</span> console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">,</span> 
</span></span><span style="display:flex;"><span>      reject <span style="color:#81a1c1">=</span> console<span style="color:#eceff4">.</span>log<span style="color:#eceff4">;</span>
</span></span></code></pre></div><p>接下来，我们需要把传递给构造器的函数补充完整。记住，我们的任务是：</p>
<ol>
<li>读取一个文件</li>
<li>如果成功，<code>resolve</code>（解决）内容</li>
<li>否则，<code>reject</code>（拒绝）并给出错误</li>
</ol>
<p>因此：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// constructor.js
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> text <span style="color:#81a1c1">=</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">new</span> <span style="color:#81a1c1">Promise</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#616e87;font-style:italic">// Normal fs.readFile call, but inside Promise constructor . . . 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>    fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;text.txt&#39;</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> text<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#616e87;font-style:italic">// . . . Call reject if there&#39;s an error . . . 
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>      <span style="color:#81a1c1;font-weight:bold">if</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> 
</span></span><span style="display:flex;"><span>        reject<span style="color:#eceff4">(</span>err<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#616e87;font-style:italic">// . . . And call resolve otherwise.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>      <span style="color:#81a1c1;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#616e87;font-style:italic">// We need toString() because fs.readFile returns a buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>        resolve<span style="color:#eceff4">(</span>text<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">})</span>
</span></span></code></pre></div><p>这样，我们就算完成工作了。这段代码会创建一个 Promise，它会严格执行我们想要的逻辑。但是，当你运行这段代码的时候，什么都不会打印出来。</p>
<h2 id="她做出了承诺然后">
  她做出了承诺，然后…
  <a class="heading-link" href="#%e5%a5%b9%e5%81%9a%e5%87%ba%e4%ba%86%e6%89%bf%e8%af%ba%e7%84%b6%e5%90%8e">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>原因是，我们写了 <code>resolve</code> 和 <code>reject</code> 方法，却并没有把它们传递给 Promise！怎么传？很简单，利用 Promise 的流程控制方法 <code>then</code> 来完成。</p>
<p>每个 Promise 对象都有一个叫做 <code>then</code> 的方法，它仅接受两个参数：<code>resolve</code> 和<code>reject</code>，且要保证顺序一致。调用 Promise 的 <code>then</code> 方法并传递这些函数，才能使构造器里的回调函数访问这两个函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#616e87;font-style:italic">// constructor.js
</span></span></span><span style="display:flex;"><span><span style="color:#616e87;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> text <span style="color:#81a1c1">=</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">new</span> <span style="color:#81a1c1">Promise</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>    fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;text.txt&#39;</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> text<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">if</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> 
</span></span><span style="display:flex;"><span>        reject<span style="color:#eceff4">(</span>err<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        resolve<span style="color:#eceff4">(</span>text<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">.</span>then<span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>这样，我们的 Promise 会读取文件，在成功时调用 <code>resolve</code> 方法。</p>
<p>有个很关键的点值得注意，<strong>then 方法永远会返回一个 Promise 对象</strong>。这就是说，你可以用多个 <code>then</code> 来构造复杂的、同步风格的流程控制，以此控制一串异步操作。在下一篇文章中我们会深入这个话题，接下来我们先用 <code>catch</code> 范例来领略一下链式调用的风采。</p>
<h2 id="捕获错误的语法糖">
  捕获错误的语法糖
  <a class="heading-link" href="#%e6%8d%95%e8%8e%b7%e9%94%99%e8%af%af%e7%9a%84%e8%af%ad%e6%b3%95%e7%b3%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>我们向 <code>then</code> 传递了两个方法：<code>resolve</code>，用于成功事件；<code>reject</code> 用于错误的事件。</p>
<p>Promise 还暴露了一个类似于 <code>then</code> 的方法，<code>catch</code>。它只接受一个参数，那就是<strong>reject</strong>。</p>
<p>由于 <code>then</code> 总是返回一个 Promise，在上面的例子中，我们可以只给 <code>then</code> 传递一个<code>resolve</code>，然后紧接着用 <code>catch</code> 来处理 reject。</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> text <span style="color:#81a1c1">=</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">new</span> <span style="color:#81a1c1">Promise</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>    fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;tex.txt&#39;</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> text<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">if</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> 
</span></span><span style="display:flex;"><span>        reject<span style="color:#eceff4">(</span>err<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        resolve<span style="color:#eceff4">(</span>text<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">.</span>then<span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">.</span><span style="color:#81a1c1;font-weight:bold">catch</span><span style="color:#eceff4">(</span>reject<span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>最后，必须要记住，<code>catch(reject)</code> 只是 <code>then(undefined, reject)</code> 的语法糖。即，我们也可以这样写：</p>
<div class="highlight"><pre tabindex="0" style="color:#d8dee9;background-color:#2e3440;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#81a1c1;font-weight:bold">const</span> text <span style="color:#81a1c1">=</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#81a1c1;font-weight:bold">new</span> <span style="color:#81a1c1">Promise</span><span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">,</span> reject<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>    fs<span style="color:#eceff4">.</span>readFile<span style="color:#eceff4">(</span><span style="color:#a3be8c">&#39;tex.txt&#39;</span><span style="color:#eceff4">,</span> <span style="color:#81a1c1;font-weight:bold">function</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">,</span> text<span style="color:#eceff4">)</span> <span style="color:#eceff4">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">if</span> <span style="color:#eceff4">(</span>err<span style="color:#eceff4">)</span> 
</span></span><span style="display:flex;"><span>        reject<span style="color:#eceff4">(</span>err<span style="color:#eceff4">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#81a1c1;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        resolve<span style="color:#eceff4">(</span>text<span style="color:#eceff4">.</span>toString<span style="color:#eceff4">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">})</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">.</span>then<span style="color:#eceff4">(</span>resolve<span style="color:#eceff4">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#eceff4">.</span>then<span style="color:#eceff4">(</span><span style="color:#81a1c1;font-weight:bold">undefined</span><span style="color:#eceff4">,</span> reject<span style="color:#eceff4">);</span>
</span></span></code></pre></div><p>但显然还是使用了语法糖的代码更易读。</p>
<h2 id="总结">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Promise 是异步编程中不可或缺的一个工具。初学时，它们显得有些可怕，但这仅仅是由于你对它还不够熟悉：多用几次，你就能像使用 <code>if</code>/<code>else</code> 一样使用它了。</p>
<p>下篇文章，我们来实践一下，把基于回调的传统代码用 Promise 进行重构。然后调研一个 Promise 库：<a href="https://github.com/kriskowal/q">Q</a>。</p>
<p>你还可以阅读一下 Domenic Denicola 的「<a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and Fates（状态与命运）</a>」来全面掌握术语，以及先前我们订购的丛书中 Kyle Simpson 关于 <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md">Promises</a> 的章节。</p>
<p>照例，如果你有问题，请在下边进行评论，或者在 Twitter 上直接找我（<a href="http://www.twitter.com/PelekeS">@PelekeS</a>）。我保证（Promise）会回复！</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "otaku-mogita" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2010 -
    
    2022
     Yun Wang 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
